<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[昂信嵌入式]]></title>
  <link href="http://www.emsym.com/atom.xml" rel="self"/>
  <link href="http://www.emsym.com/"/>
  <updated>2015-07-15T11:08:30+08:00</updated>
  <id>http://www.emsym.com/</id>
  <author>
    <name><![CDATA[苏州昂信科技有限公司]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[java基础之JNI原理]]></title>
    <link href="http://www.emsym.com/blog/2015/07/03/javaji-chu-zhi-jniyuan-li/"/>
    <updated>2015-07-03T00:43:59+08:00</updated>
    <id>http://www.emsym.com/blog/2015/07/03/javaji-chu-zhi-jniyuan-li</id>
    <content type="html"><![CDATA[<p>利用JNI实现安卓的Java代码调用C语言API。</p>

<!--more-->


<p>JNI是Java Native Interface的缩写，也就是Java本地接口的意思。Java为什么需要JNI这种呢？我们知道Java是一种平台无关性的语言，平台对于上层的java代码来说是透明的，在大部分的情况下是不需要JNI的，但是我们可能遇到如下一下情况:</p>

<p>1.java代码需要得到一个文件的属性，但是找不到相关的API；</p>

<p>2.在java代码中需要用到某种算法，但是这种算法时用C实现并封装在动态链接库文件中的。</p>

<p>如果没有JNI，上面的问题就会变得很棘手.举个例子说明:在Android中我们想要操作串口的时候会发现当前的Android SDK并没有提供任何写串口的API，对于底层的串口操作需要使用C来完成。而Android的应用程序是基于java实现的，应用程序想要访问到串口就需要JNI技术了。</p>

<p>接下来通过实际的例子来说明java如何通过JNI实现C\C++的函数调用</p>

<h5>1.开发环境介绍：主机系统为64位Ubuntu 14.04， jdk版本jdk1.8.0_45。</h5>




<h5>2.程序清单1～/jni_test/com/magc/jni/HelloWorld.java</h5>




<div class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">magc</span><span class="o">.</span><span class="na">jni</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloWorld</span>
<span class="o">{</span>
    <span class="kd">static</span>
    <span class="o">{</span>
        <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;Hello&quot;</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">DisplayHello</span><span class="o">();</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">new</span> <span class="nf">HelloWorld</span><span class="o">().</span><span class="na">DisplayHello</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></div>




<h5>3.进如jni目录后，编译该java类，命令：</h5>


<p><code>javac HelloWorld.java</code></p>

<p>执行后在该目录下生成 HelloWorld.class 文件</p>

<h5>4.进入jni_test目录，使用javah命令生成头文件：</h5>


<p><code>javah -jni com.magc.jni.HelloWorld</code></p>

<p>在当前目录下生成 com_magc_jni_HelloWrold.h 头文件</p>

<h5>5.程序清单2 com_magc_jni_HelloWrold.h</h5>




<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* DO NOT EDIT THIS FILE - it is machine generated */</span>
<span class="cp">#include &lt;jni.h&gt;</span>
<span class="cm">/* Header for class com_magc_jni_HelloWorld */</span>

<span class="cp">#ifndef _Included_com_magc_jni_HelloWorld</span>
<span class="cp">#define _Included_com_magc_jni_HelloWorld</span>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif</span>
    
<span class="cm">/*</span>
<span class="cm"> * Class:     com_magc_jni_HelloWorld</span>
<span class="cm"> * Method:    DisplayHello</span>
<span class="cm"> * Signature: ()V</span>
<span class="cm"> */</span>
    
<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="n">Java_com_magc_jni_HelloWorld_DisplayHello</span>
    <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">);</span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span></code></pre></div>


<p>此头文件中的Java_com_magc_jni_HelloWorld_DisplayHello(JNIEnv *, jobject)方法，是将来与动态链接库交互的接口，并需要名字保持一致。</p>

<h5>6.程序清单3 jni_HelloWroldlmpl.cpp</h5>


<p>在jni_test目录下新建jni_HelloWroldlmpl.cpp源文件</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#include &lt;jni.h&gt;</span>
<span class="cp">#include &quot;com_magc_jni_HelloWorld.h&quot;</span>
<span class="cp">#include &quot;stdio.h&quot;</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span> <span class="nf">Java_com_magc_jni_HelloWorld_DisplayHello</span>
    <span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="p">,</span> <span class="n">jobject</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;From jni_helloworldImpl.cpp :&quot;</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello world !</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>


<p>此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。</p>

<h5>7.编译生成动态库libHello.so,命令：</h5>


<p><code>g++ jni_helloworldImpl.cpp -o libHello.so</code></p>

<p>成功后，便会在当前目录下生成动态链接库libHello.so文件。</p>

<p>本人在执行这一步的过程中遇到了头文件&#8221;jni.h&#8221;和&#8221;jni_md.h&#8221;未找到的情况，这两个头文件路径伟jdk安装目录下include 及include/linux
使用&#8221;g++ -shared -I 头文件路径&#8221;解决.</p>

<h5>8.有了具体实现的动态库后，就可以运行JAVA调用JNI程序类的native方法了。命令：</h5>


<p><code>java -Djava.library.path=. com.magc.jni.HelloWorld</code></p>

<p>输入结果即为：From jni_helloworldImpl.cpp :Hello world !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RTU]]></title>
    <link href="http://www.emsym.com/blog/2015/06/05/rtu/"/>
    <updated>2015-06-05T12:53:07+08:00</updated>
    <id>http://www.emsym.com/blog/2015/06/05/rtu</id>
    <content type="html"><![CDATA[<p>RTU的英文全称为Remote Terminal Unit, 中文全称远程终端单元。</p>

<p>RTU具有的特点是:</p>

<p>1.通信距离较长;</p>

<p>2.用于各种环境恶劣的工业现场;</p>

<p>3.模块结构化设计，便于扩展;</p>

<p>4.在具有遥信，遥测，遥控的领域的水利等行业广泛使用。</p>

<p>RTU是一种远程测控单元装置，负责对现场的信号及工业设备的监测和控制。与常用的PLC相比，RTU具有优良的通讯能力，更多的计算功能，适用于更恶劣的温度及湿度环境。针对水环境监测及控制的需求，开发出一款实用性及良好的扩展性兼备的RTU，型号为XXXX</p>

<p>该款RTU有如下特点:</p>

<p>1.采用24V供电系统;</p>

<p>2.8路控制输出，输出电平可配置为5V或12V，具有较好的兼容性;</p>

<p>3.8路电平输入，采用光耦隔离，具备良好的抗干扰能力;</p>

<p>4.模拟电压信号输入;</p>

<p>5.4-20mA电流信号输入;</p>

<p>6.RS485通信接口;</p>

<p>7.高速USB通信接口;</p>

<p>8.SPI通信接口;</p>

<p>9.采用modbus-rtu通信协议;</p>

<p>10.使用高性能的32位ARM-Cortex处理芯片;</p>

<p>11.预留I/O扩展功能。</p>

<p>备注：模拟电压及电流信号输入共用12个模拟信号采集通道，可根据实际需求进行组合配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[pH值 水质测量设备的物联网化]]></title>
    <link href="http://www.emsym.com/blog/2015/05/01/measurement-of-ph/"/>
    <updated>2015-05-01T17:42:16+08:00</updated>
    <id>http://www.emsym.com/blog/2015/05/01/measurement-of-ph</id>
    <content type="html"><![CDATA[<p>目前工业上广泛使用的各类变送器大致可以分为两类。第一类为模拟量输出，输出
为4-20mA电流信号。第二类为数字信号输出，该类变送器多配有串行的通信
接口(如RS485)。也有一些变送器同时配有这两种接口。</p>

<p>水质的酸碱度由一个传感器采集，传感器输出信号经过变送器之后输出显示，如图1
所示的一个正在工作的PH/ORP变送器：
<img class="center" src="http://www.emsym.com/assets/2015/ph-measurement.jpg" width="500">
图1：变送器工作状态</p>

<p>图1所示的变送器输出的是4-20mA的电流信号。电路信号通过采样电阻可以转变为容
易测量的电压信号，如图2所示：将转变后的电压信号输入外部的采集板。
<img class="center" src="http://www.emsym.com/assets/2015/fsl-KEA-with-pH.jpg" width="500">
图2：采集板</p>

<p>图3为外部的采集板采集到的数据，与图1中显示的电流值相比，两者相差0.34mA。
<img class="center" src="http://www.emsym.com/assets/2015/current-measurement.jpg" width="500">
图3：实际采集到的电流值</p>

<p>由于变送器不具备控制功能，因此在需要保持水环境在一定的酸碱度范围内的情况下，
需要设计一个酸碱度控制器，控制器实时监测酸碱度，在其超出设定范围后控制
化学药剂的使用量来调整水的酸碱度。</p>

<p>随着自动化水平的提高，现场作业人员的数量逐渐减少，各类控制器的数量却随之增
加。现如今我们对于信息获取的速度要求也越来越高，而数据量越来越大，为此设备
的物联网化是一个行之有效的方法：控制器实现工业现场离散信息的获取，通过总线
将获取到的信息汇总至中央处理模块，该模块负责数据的分析处理，实时显示及上传
等工作，最终实现与移动终端的互联。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Golang 编译windows应用程序]]></title>
    <link href="http://www.emsym.com/blog/2015/04/21/golang-for-windows/"/>
    <updated>2015-04-21T22:54:38+08:00</updated>
    <id>http://www.emsym.com/blog/2015/04/21/golang-for-windows</id>
    <content type="html"><![CDATA[<p>因为我们更喜欢在Linux上开发程序，
所以生成交叉编译器，以便在Linux上交叉编译出windows程序。</p>

<div class="highlight"><pre><code class="language-console" data-lang="console"><span class="gp">#</span> 安装minGW：在Linux上运行gcc交叉编译生成windows程序
<span class="gp">#</span> 我们用到Cgo，因此需要安装 C 语言交叉编译器
<span class="go">sudo apt-get install gcc-mingw-w64</span>

<span class="gp">#</span> 下载Go语言的源代码
<span class="go">git clone https://github.com/golang/go.git</span>

<span class="gp">#</span> 32-bit go-compiler <span class="k">for</span> windows
<span class="go">GOOS=windows GOARCH=386 CGO_ENABLED=1 CXX_FOR_TARGET=i686-w64-mingw32-g++ CC_FOR_TARGET=i686-w64-mingw32-gcc ./make.bash</span>

<span class="gp">#</span> 64-bit 编译器
<span class="go">GOOS=windows GOARCH=amd64 CGO_ENABLED=1 CXX_FOR_TARGET=x86_64-w64-mingw32-g++ CC_FOR_TARGET=x86_64-w64-mingw32-gcc ./make.bash </span>

<span class="gp">#</span> 非交叉编译，生成Linux程序
<span class="go">GOOS=linux GOARCH=amd64 CGO_ENABLED=1 CXX_FOR_TARGET=g++ CC_FOR_TARGET=gcc ./make.bash </span>

<span class="gp">#</span> 生成Go编译器之后，以下命令执行交叉编译，生成windows程序
<span class="go">GOOS=windows GOARCH=386 go build</span></code></pre></div>


<h1>Cgo </h1>

<p><img class="right" src="http://www.emsym.com/assets/2015/ffmpeg-win.png" width="627">
最终的目标是要生成windows程序，所以Cgo引用的库文件也必须是windows版本的。
以ffmpeg库为例：参考截图，在ffmpeg文件夹之下，新建一个文件夹，名为libwin，
用于保存windows版本的库文件（dll文件）。</p>

<p>pkgconfig 也需要做相应调整。而头文件无需变动。</p>

<p>准备工作只有这么多了。通过指定pkgconfig的路径，就能够交叉编译Cgo程序了。
<code>GOOS=windows GOARCH=386 PKG_CONFIG_PATH=/foo/bar go build</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Blog系统迁移]]></title>
    <link href="http://www.emsym.com/blog/2015/04/20/migration-of-the-blog/"/>
    <updated>2015-04-20T23:08:17+08:00</updated>
    <id>http://www.emsym.com/blog/2015/04/20/migration-of-the-blog</id>
    <content type="html"><![CDATA[<p>我们将Blog系统，从wordpress迁移到Jekyll &amp; octopress。
最大的好处是，可以在github编辑页面。</p>

<p>几天之内，我们会将老系统的内容也复制过来。</p>
]]></content>
  </entry>
  
</feed>
